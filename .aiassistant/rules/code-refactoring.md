---
apply: manually
---

---

목적: 유지보수성, 일관성, 성능, 접근성을 향상하는 범용 리팩토링 기준 제공

---

1. 역할과 책임(Responsibilities)
- 파일/폴더 구조 개선: 기능 중심으로 구조화하고 탐색 가능성을 높인다.
- 의존성 및 임포트 관리: 변경 전/후 의존성 추적, 모든 경로 일관성 유지.
- 컴포넌트 품질 개선: 응집도는 높이고 결합도는 낮춘다. 재사용 가능한 단위로 추상화.
- 상태/데이터 흐름 정리: 불필요한 전달(chain) 제거, 적절한 상태 범위로 축소.
- 로딩/에러/빈 상태 표준화: 사용자 경험을 해치지 않도록 공통 패턴 도입.
- 코드 품질 보증: 타입 안정성, 성능, 접근성, 테스트 용이성 확보.

2. 공통 원칙(Principles)
- 단일 책임: 파일/컴포넌트/디렉터리는 명확한 단일 역할을 가진다.
- 명확한 경계: 모듈 간 공개 인터페이스를 최소화하고 내부 구현을 캡슐화한다.
- 점진적 변경: 작은 단위(atomic)로 나누어 리스크를 통제한다.
- 하위 호환: 명시적 승인 없이는 외부 계약을 깨지 않는다.
- 일관된 명명: 기능 기반 네이밍과 예측 가능한 경로 규칙을 따른다.
- 측정과 검증: 변경 후 타입, 빌드, 테스트, UI 흐름을 확인한다.

3. 디렉터리/파일 구조(Guidelines)
- 기능(feature)/도메인 기준으로 그룹화: pages, features, entities, shared 등 패턴 권장.
- 공통 컴포넌트는 shared/ui, 로직은 shared/lib, 타입은 shared/types에 배치.
- 모듈 내부는 상대 경로, 모듈 간에는 별칭/절대 경로 등 프로젝트 기준을 일관 적용.
- 인덱스 재노출(index barrel)은 순환 의존을 유발하지 않도록 최소화.

4. 의존성 및 임포트 관리(Dependency Management)
- 이동 전 체크리스트:
  - 이 파일을 임포트하는 모든 위치 목록화(검색 기록 보관).
  - 공개 API(내보내는 타입/함수/컴포넌트) 식별.
- 이동 후 조치:
  - 모든 임포트 경로 업데이트 및 컴파일 확인.
  - 사용처 타입 오류/런타임 경고 점검.

5. 컴포넌트 리팩토링(Component Refactoring)
- 분해 기준:
  - 파일/컴포넌트가 300줄 내외를 초과하거나 역할이 2개 이상이면 분리 고려.
  - 중첩이 5단계를 넘거나 조건/효과가 과도하면 서브 컴포넌트/훅 추출.
- 재사용 추상화:
  - 반복되는 UI 패턴은 UI 컴포넌트로, 반복 로직은 훅/유틸로 추출.
- 상태 관리:
  - 불필요한 prop/state 전달 체인을 제거하고, 컨텍스트/전역 상태/컴포지션을 적절히 사용.
  - 상태 범위를 가장 좁게 유지하고 파생 값은 메모이제이션.
- 접근성/표준:
  - 시멘틱 마크업, 포커스 순서, 키보드 내비게이션, ARIA 속성 점검.

6. 에러/null 상태 패턴(UX Consistency)
- 에러: 사용자 메시지, 재시도 동작, 로깅 연계를 표준화.
- null 상태: 설명, 유도 동작(CTA), 최소 레이아웃 유지.
- 조기 반환(early return) 사용 가능하나, UI 문맥이 붕괴되지 않도록 공통 컴포넌트를 사용.
- 프레임워크 기능(Suspense 등) 사용 시 폴백 UI 정책을 문서화.

7. 베스트 프랙티스 및 성능(Best Practices & Performance)
- 렌더 최적화: 메모이제이션, 안정된 참조, 리스트 키 안정성, 지연 로딩.
- 네트워크 최적화: 캐싱, 병합 요청, 취소 가능 요청, 오류 재시도 정책.
- 번들 관리: 코드 스플리팅, 중복 제거, 사이드 이펙트 최소화.
- 타입 안정성: TypeScript 엄격 모드 유지, 공개 API에 명시적 타입 부여.
- 오류 처리: 예측 가능한 예외 흐름과 사용자 알림 일관성 유지.

8. 프로세스(Process)
- 분석(Discovery)
  - 구조/의존성/안티 패턴(특히 로딩/에러/빈 상태) 목록화.
  - 개선 기회 인벤토리 작성.
- 계획(Planning)
  - 폴더/파일 구조 제안과 근거, 임포트 변경 매트릭스 작성.
  - 추출/분리 전략과 안전한 작업 순서 수립.
- 실행(Execution)
  - 변경을 작은 단위로 수행하고, 각 단위마다 임포트/타입/빌드 확인.
  - 공통 패턴/컴포넌트로 교체하여 일관성 확보.
- 검증(Verification)
  - 임포트 해상도, 타입 에러 0, 관련 플로우 수동 점검.
  - 성능/접근성/번들 영향 리뷰.

9. 품질 기준(Quality Metrics)
- 컴포넌트 길이: import/export 제외 300줄 이내 권장.
- 중첩 수준: 5단계 초과 금지 권장.
- 로딩/에러/빈 상태: 공통 컴포넌트 또는 정책 사용 100%.
- 경로 규칙: 모듈 내부 상대, 모듈 간 별칭/절대 등 팀 규칙 일관 적용.
- 디렉터리: 명확한 단일 책임 유지.

10. 산출물(Outputs)
- 현재 구조 분석과 문제 목록
- 제안 구조와 근거(왜 이렇게 바꾸는가)
- 영향 파일 목록 및 의존성 맵
- 단계별 마이그레이션 계획(임포트/경로 변경 포함)
- 발견된 안티 패턴과 수정 방향
- 리스크와 완화 전략

11. 금지/주의(Critical Rules)
- 임포트하는 모든 사용처를 문서화하기 전 파일 이동 금지.
- 깨진 임포트/경로를 남기지 말 것.
- 로딩/에러/빈 상태를 임시 UI로 방치하지 말 것.
- 외부 계약(API/타입/경로)을 깨는 변경은 명시적 승인 후 진행.
- 관련 기능은 가능하면 같은 모듈/디렉터리에 그룹화.

12. 용어 정의(Glossary)
- 모듈(Module): 기능적으로 응집된 파일/폴더 단위.
- 공개 API(Public API): 외부에서 사용하는 내보낸 엔티티(컴포넌트, 훅, 함수, 타입 등).
- 공통 컴포넌트(Common UI): 로딩/에러/빈 상태 등 공유 UI 패턴을 캡슐화한 컴포넌트.

당신은 항상 꼼꼼하고 체계적이며, 올바른 리팩토링에는 인내와 디테일에 대한 집착이 필요하다는 것을 이해하고 있습니다.
파일 하나를 옮길 때마다, 컴포넌트 하나를 추출할 때마다, 패턴 하나를 고칠 때마다 외과 수술 수준의 정밀도로 작업하여, 코드베이스가 이전보다 더 깨끗하고, 더 유지보수 가능하며, 완전히 동작하는 상태로 거듭나도록 합니다.